<!DOCTYPE html>
<html lang="en">
  <body>
    <nav><div>
    <a class="internal-link" href="/garden/"><b>Seoyeon Lee</b></a>
</div>
</nav>
    <div class="wrapper">
      <main><article>
  <div>
    <h1>Neural anticipation of virtual infection triggers an immune response</h1>
    <time datetime="2025-08-07T19:26:26+09:00">
      Last updated on August 7, 2025
      
    </time>
  </div>

  <div id="notes-entry-container">
    <content>
      <h1 id="neural-anticipation-of-virtual-infection-triggers-an-immune-response">Neural anticipation of virtual infection triggers an immune response</h1>
<h2 id="summary">Summary</h2>
<h3 id="저자-정보">저자 정보</h3>
<p><strong>교신저자</strong>:<br>
Camilla Jandus (면역학, University of Geneva)<br>
Andrea Serino (인지신경과학, University of Lausanne)</p>

<hr>

<h3 id="논문-기본-정보">논문 기본 정보</h3>
<ul>
  <li>
<strong>저자</strong>: Sara Trabanelli, Michel Akselrod, Julia Fellrath, Giulia Vanoni, et al.</li>
  <li>
<strong>소속</strong>: University of Lausanne, University of Geneva 외</li>
  <li>
<strong>저널</strong>: <em>Nature Neuroscience</em>
</li>
  <li>
<strong>발행연도</strong>: 2025</li>
  <li>
<strong>DOI</strong>: <a href="https://doi.org/10.1038/s41593-025-02008-y" target="_blank">10.1038/s41593-025-02008-y</a>
</li>
</ul>

<hr>

<h3 id="tldr-">TL;DR 🧠💥</h3>
<p>가상현실(VR)에서 감염 위협을 예측하는 뇌 반응이 실제 면역 반응을 유도할 수 있으며, 이는 peripersonal space(PPS) 시스템과 HPA 축을 매개로 하는 새로운 신경–면역 교차 신호 경로를 시사한다.</p>

<hr>

<h3 id="주요-발견-highlights-">주요 발견 (Highlights) 🌟</h3>
<ul>
  <li>감염 징후가 있는 아바타가 접근할 때, <strong><span title="There is no note that matches this link." class="invalid-link">  <span class="invalid-link-brackets">[[</span>  PPS  <span class="invalid-link-brackets">]]</span></span> 관련 뇌 영역</strong>(전운동, 두정엽, ACC 등)이 <strong>먼 거리에서도 조기 활성화</strong>됨</li>
  <li>이러한 뇌 반응은 <strong>감염성 아바타와 실제 독감 백신 접종 모두</strong>에서 <strong><span title="There is no note that matches this link." class="invalid-link">  <span class="invalid-link-brackets">[[</span>  innate lymphoid cells (ILCs)의 활성 및 빈도 변화  <span class="invalid-link-brackets">]]</span></span></strong>를 유발
    <ul>
      <li>여기서 궁금한점 ; 그러면 일부러 PPS 를 활성화 시켰을때도 ILC의 활성이 정가하나?</li>
    </ul>
  </li>
  <li>
<strong>fMRI와 DCM 분석</strong>은 감염 예측 시 <strong>전전두엽–시상하부–HPA axis</strong> 간의 기능적 연결성 증가를 보여줌</li>
  <li>
<strong>머신러닝 기반 신경망 모델</strong>은 호르몬, eicosanoid, 염증 인자의 복합 신호를 통해 ILC 활성도를 성공적으로 예측</li>
</ul>

<hr>

<h3 id="방법-methods-">방법 (Methods) 🔬</h3>
<ul>
  <li>
<strong>참가자</strong>: 건강한 성인 248명, 여러 독립 코호트 (VR, EEG, fMRI, 면역반응, 백신 대조군 등)</li>
  <li>
<strong>자극</strong>: 감염, 중립, 공포 아바타 (VR 환경에서 제시)</li>
  <li>
<strong>측정기법</strong>:
    <ul>
      <li>행동 반응: 얼굴 촉각 반응 시간 기반 PPS 파악</li>
      <li>EEG (128채널), fMRI (3T), Dynamic Causal Modeling</li>
      <li>Flow cytometry (ILC/NK cell 분류 및 활성화 마커)</li>
      <li>Mass spectrometry: HPA-related hormones, eicosanoids, neuroinflammatory markers</li>
      <li>Neural network 모델링: 다중 신경–면역 신호 입력 → ILC 활성 예측</li>
    </ul>
  </li>
</ul>

<hr>

<h3 id="소챕터별-내용-요약-">소챕터별 내용 요약 📘</h3>

<h4 id="-vr-감염-위협에-대한-pps-반응">🟢 VR 감염 위협에 대한 PPS 반응</h4>
<ul>
  <li>감염성 아바타가 멀리서 접근할 때도 PPS 효과가 확장됨 → 위험 예측 반응의 공간적 범위가 확대됨</li>
</ul>

<h4 id="-eeg-분석">🟡 EEG 분석</h4>
<ul>
  <li>129–150ms 사이에 감염 아바타에 대한 <strong>Fronto–Parietal 영역 활성화</strong> 확인</li>
</ul>

<h4 id="-면역-반응-측정">🔴 면역 반응 측정</h4>
<ul>
  <li>감염성 아바타 노출 후 <strong>ILC 빈도 및 활성도 증가</strong>, 백신 접종 후와 유사한 면역 프로파일</li>
  <li>특히 <strong>ILC2, ILCP 증가</strong>, ILC1 감소 (조직 이동 가능성)</li>
</ul>

<h4 id="-fmri-분석">🔵 fMRI 분석</h4>
<ul>
  <li>
<strong>멀리 있는 감염성 아바타</strong>는 aINS, mPFC, ACC 등 <strong><mark>salience network</mark></strong>와 <strong>S1</strong> 활성화 유도</li>
  <li>
<mark>공포 아바타와 구별</mark>되는 감염-특이적 활성화 패턴</li>
</ul>

<h4 id="-시상하부-연결성-분석-dcm">🟣 시상하부 연결성 분석 (DCM)</h4>
<ul>
  <li>감염성 자극 시 <strong><mark>시상하부–salience/PPS 영역 간 연결성</mark> 증가</strong>
    <ul>
      <li>감염성 자극이라는게 감염병 환자가 온다는 얘기?</li>
    </ul>
  </li>
  <li>특히 좌측 전전두엽과 우측 일차체감각피질이 핵심 연결 경로</li>
</ul>

<h4 id="️-신경망-모델링">⚙️ 신경망 모델링</h4>
<ul>
  <li>HPA 관련 호르몬, eicosanoid, 염증 인자 → hidden layer 신경망 입력</li>
  <li>
<strong>ILC 활성도 예측 정확도 R² = 0.71</strong>, 감염 코호트는 예측치 hotspot에 몰림
    <ul>
      <li>이 부분은 논문 확인이 좀 더 필요할듯</li>
    </ul>
  </li>
</ul>

<hr>

<h3 id="discussion-요약-">Discussion 요약 🧩</h3>
<ul>
  <li>
<strong>PPS 시스템</strong>과 <strong>salience network</strong>는 감염 신호를 사전에 감지하고 HPA 축을 통해 면역계를 활성화할 수 있음</li>
  <li>이는 <strong>행동 면역 시스템(회피, 거리두기)</strong>과 <strong>생물학적 면역 시스템(ILC 반응)</strong>의 통합적 조기 반응을 시사</li>
  <li>감염을 예측하는 <strong>‘연기 탐지기’ 모델</strong>과 유사한 생물학적 원리 제안</li>
  <li>VR 기반 감염 자극도 <strong>실제 면역 활성화</strong>를 유도할 수 있다는 점에서 <strong>신경–면역 연구 및 정신신경면역학 분야에 새 이정표</strong>
</li>
</ul>

<hr>

<h3 id="모델이-정리한-추가-인사이트-">모델이 정리한 추가 인사이트 🔍</h3>
<ul>
  <li>감염성 위협에 대한 조기 반응이 실제 면역 반응을 유도함으로써, <strong>가상 시뮬레이션을 통한 예방적 면역 강화 전략</strong>이 가능할 수 있음</li>
  <li>
<strong>PPS 확장성</strong>은 감염 공포뿐 아니라 <strong>심리사회적 스트레스 자극</strong>에 따른 뇌–면역 반응 연구에 확장될 수 있음</li>
  <li>사회적 회피 행동이 감염 회피뿐 아니라 <strong>내재면역 조절 전략</strong>으로 작동한다는 점을 실험적으로 검증</li>
</ul>

<h2 id="related-article">Related Article</h2>

<h2 id="abstract">Abstract</h2>
<blockquote>
  <p>[!Abstract]
Once contact with a pathogen has occurred, it might be too late for the immune system to react. Here, we asked whether anticipatory neural responses might sense potential infections and signal to the immune system, priming it for a response. We show that potential contact with approaching infectious avatars, entering the peripersonal space in virtual reality, are anticipated by multisensory–motor areas and activate the salience network, as measured with psychophysics, electroencephalography and functional magnetic resonance imaging. This proactive neural anticipation instigates changes in both the frequency and activation of innate lymphoid cells, mirroring responses seen in actual infections. Alterations in connectivity patterns between infection-sensing brain regions and the hypothalamus, along with modulation of neural mediators, connect these effects to the hypothalamic–pituitary–adrenal axis. Neural network modeling recapitulates this neuro–immune cross-talk. These findings suggest an integrated neuro–immune reaction in humans toward infection threats, not solely following physical contact but already after breaching the functional boundary of body–environment interaction represented by the peripersonal space.</p>
</blockquote>

      <p>This line appears after every note.</p>
    </content>

    <side style="font-size: 0.9em">
      <h3 style="margin-bottom: 1em">Notes mentioning this note</h3>
      

      <div style="font-size: 0.9em">
        <p>
          There are no notes linking to this note.
        </p>
      </div>
      
    </side>
  </div>
</article>

<hr>

<p>Here are all the notes in this garden, along with their links, visualized as a graph.</p>

<style>
  .links line {
    stroke: #ccc;
    opacity: 0.5;
  }

  .nodes circle {
    cursor: pointer;
    fill: #8b88e6;
    transition: all 0.15s ease-out;
  }

  .text text {
    cursor: pointer;
    fill: #333;
    text-shadow: -1px -1px 0 #fafafabb, 1px -1px 0 #fafafabb, -1px 1px 0 #fafafabb, 1px 1px 0 #fafafabb;
  }

  .nodes [active],
  .text [active] {
    cursor: pointer;
    fill: black;
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper {
    background: #fcfcfc;
    border-radius: 4px;
    height: auto;
  }
  
  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      oScript.onload = () => {
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 12;
        const ACTIVE_RADIUS_FACTOR = 1.5;
        const STROKE = 1;
        const FONT_SIZE = 16;
        const TICKS = 200;
        const FONT_BASELINE = 40;
        const MAX_LABEL_LENGTH = 50;

        const graphData = {"edges":[{"source":"891111171143210210511411511632115101101100","target":"66111110329711211219516911610511633"},{"source":"891111171143210210511411511632115101101100","target":"6532110111116101329798111117116329997116115"},{"source":"891111171143210210511411511632115101101100","target":"84105103101114115"},{"source":"77111118101321211111171143298111100121321011181011141213210097121","target":"67111110115105115116101110991213210511532107101121"},{"source":"6532110111116101329798111117116329997116115","target":"77111118101321211111171143298111100121321011181011141213210097121"},{"source":"67111110115105115116101110991213210511532107101121","target":"891111171143210210511411511632115101101100"},{"source":"891111171143210210511411511632115101101100","target":"236149136235133149237149152236132184236154148"}],"nodes":[{"id":"66111110329711211219516911610511633","path":"/garden/accents","label":"Bon appétit!"},{"id":"6532110111116101329798111117116329997116115","path":"/garden/cats","label":"A note about cats"},{"id":"84105103101114115","path":"/garden/tigers","label":"Tigers"},{"id":"67111110115105115116101110991213210511532107101121","path":"/garden/consistency","label":"Consistency is key"},{"id":"77111118101321211111171143298111100121321011181011141213210097121","path":"/garden/move-your-body-every-day","label":"Move your body every day"},{"id":"7797110117115991141051121169511611111697108","path":"/garden/manuscript-total","label":"Manuscript_total"},{"id":"6510010010511610511111097108329711097108121115105115","path":"/garden/additional-analysis","label":"Additional analysis"},{"id":"50534855514895102114111109951151041141051091129511611195100111108112104105110","path":"/garden/250730-from-shrimp-to-dolphin","label":"250730_from_shrimp_to_dolphin"},{"id":"123123116105116108101125125","path":"/garden/journal-summary","label":""},{"id":"7311010010511810510011797108321001051021021011141011109910111532105110321001019910511510511111045109971071051101033211510497112101321041111193210910111511110810510998105993210011111297109105110101321141011031171089711610111532991041111059910132991111101021051001011109910132971101003299104971101031014511110245109105110100","path":"/garden/kocharianetalnatneurosci2025","label":"Individual differences in decision-making shape how mesolimbic dopamine regulates choice confidence and change-of-mind"},{"id":"65321021081011201059810810132104105112112111999710911297108321121111121171089711610511111032991111001013210211111432101120112101114105101110991013211410110897116105118101321161113211410111997114100","path":"/garden/sosaetalnatneurosci2025","label":"A flexible hippocampal population code for experience relative to reward"},{"id":"86111108116971031013210510997103105110103321141011181019710811532104105112112111999710911297108321051101041059810511611111412132100121110971091059911532115104971121051101033211212111497109105100971083210910110911111412145101110991111001051101033211510111311710111099101115","path":"/garden/taxidisetalnatneurosci2025","label":"Voltage imaging reveals hippocampal inhibitory dynamics shaping pyramidal memory-encoding sequences"},{"id":"6511032105110116101103114971161011003211510511010310810145110117991081011171153297110100321151129711610597108321161149711011599114105112116111109105991153297116108971153211410111810197108115321161041013210911110810199117108971143210897110100115999711210132111102321161041013210411710997110321041051121121119997109112117115","path":"/garden/thompsonetalnatneurosci2025","label":"An integrated single-nucleus and spatial transcriptomics atlas reveals the molecular landscape of the human hippocampus"},{"id":"78101117114971083297110116105991051129711610511111032111102321181051141161179710832105110102101991161051111103211611410510310310111411532971103210510910911711010132114101115112111110115101","path":"/garden/trabanellietalnatneurosci2025a","label":"Neural anticipation of virtual infection triggers an immune response"},{"id":"8710110899111109101","path":"/garden/welcome","label":"Welcome"},{"id":"891111171143210210511411511632115101101100","path":"/garden/your-first-note","label":"Your first seed"},{"id":"236149136235133149237149152236132184236154148","path":"/garden/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94","label":"안녕하세요"}]}
        let nodesData = graphData.nodes;
        let linksData = graphData.edges;

        const nodeSize = {};

        const updateNodeSize = () => {
          nodesData.forEach((el) => {
            let weight =
              3 *
              Math.sqrt(
                linksData.filter((l) => l.source.id === el.id || l.target.id === el.id)
                  .length + 1
              );
            if (weight < MINIMAL_NODE_SIZE) {
              weight = MINIMAL_NODE_SIZE;
            } else if (weight > MAX_NODE_SIZE) {
              weight = MAX_NODE_SIZE;
            }
            nodeSize[el.id] = weight;
          });
        };

        const onClick = (d) => {
          window.location = d.path
        };

        const onMouseover = function (d) {
          const relatedNodesSet = new Set();
          linksData
            .filter((n) => n.target.id == d.id || n.source.id == d.id)
            .forEach((n) => {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", (node_d) => {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", (link_d) => {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", (link_d) => {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 4;
            }
            return STROKE;
          });
          text.attr("class", (text_d) => {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        };

        const onMouseout = function (d) {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        };

        const sameNodes = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const map = new Map();
          for (const node of previous) {
            map.set(node.id, node.label);
          }

          for (const node of next) {
            const found = map.get(node.id);
            if (!found || found !== node.title) {
              return false;
            }
          }

          return true;
        };

        const sameEdges = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const set = new Set();
          for (const edge of previous) {
            set.add(`${edge.source.id}-${edge.target.id}`);
          }

          for (const edge of next) {
            if (!set.has(`${edge.source.id}-${edge.target.id}`)) {
              return false;
            }
          }

          return true;
        };

        const graphWrapper = document.getElementById('graph-wrapper')
        const element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        element.setAttribute("width", graphWrapper.getBoundingClientRect().width);
        element.setAttribute("height", window.innerHeight * 0.8);
        graphWrapper.appendChild(element);

        const reportWindowSize = () => {
          element.setAttribute("width", window.innerWidth);
          element.setAttribute("height", window.innerHeight);
        };

        window.onresize = reportWindowSize;

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));
        let zoomLevel = 1;

        const simulation = d3
          .forceSimulation(nodesData)
          .force("forceX", d3.forceX().x(width / 2))
          .force("forceY", d3.forceY().y(height / 2))
          .force("charge", d3.forceManyBody())
          .force(
            "link",
            d3
              .forceLink(linksData)
              .id((d) => d.id)
              .distance(70)
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(80))
          .stop();

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const resize = () => {
          if (d3.event) {
            const scale = d3.event.transform;
            zoomLevel = scale.k;
            g.attr("transform", scale);
          }

          const zoomOrKeep = (value) => (zoomLevel >= 1 ? value / zoomLevel : value);

          const font = Math.max(Math.round(zoomOrKeep(FONT_SIZE)), 1);

          text.attr("font-size", (d) => font);
          text.attr("y", (d) => d.y - zoomOrKeep(FONT_BASELINE) + 8);
          link.attr("stroke-width", zoomOrKeep(STROKE));
          node.attr("r", (d) => {
            return zoomOrKeep(nodeSize[d.id]);
          });
          svg
            .selectAll("circle")
            .filter((_d, i, nodes) => d3.select(nodes[i]).attr("active"))
            .attr("r", (d) => zoomOrKeep(ACTIVE_RADIUS_FACTOR * nodeSize[d.id]));
        };

        const ticked = () => {
          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          text
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - (FONT_BASELINE - nodeSize[d.id]) / zoomLevel);
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        };

        const restart = () => {
          updateNodeSize();
          node = node.data(nodesData, (d) => d.id);
          node.exit().remove();
          node = node
            .enter()
            .append("circle")
            .attr("r", (d) => {
              return nodeSize[d.id];
            })
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(node);

          link = link.data(linksData, (d) => `${d.source.id}-${d.target.id}`);
          link.exit().remove();
          link = link.enter().append("line").attr("stroke-width", STROKE).merge(link);

          text = text.data(nodesData, (d) => d.label);
          text.exit().remove();
          text = text
            .enter()
            .append("text")
            .text((d) => shorten(d.label.replace(/_*/g, ""), MAX_LABEL_LENGTH))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

          node.attr("active", (d) => isCurrentPath(d.path) ? true : null);
          text.attr("active", (d) => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);
          simulation.alpha(1).restart();
          simulation.stop();

          for (let i = 0; i < TICKS; i++) {
            simulation.tick();
          }

          ticked();
        };

        const zoomHandler = d3.zoom().scaleExtent([0.2, 3]).on("zoom", resize);

        zoomHandler(svg);
        restart();

        function isCurrentPath(notePath) {
          return window.location.pathname.includes(notePath)
        }

        function shorten(str, maxLen, separator = ' ') {
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
      }
    }
  </script>
</div>

</main>
      <footer>


  <footer class="sticky-bottom mt-5" role="contentinfo">
    

    <div class="container">
      
  &copy; Copyright 2025
  Seoyeon
  
  Lee. 
  
  

    </div>
  </footer>

</footer>
    </div>

    <!-- That file is not particularly elegant. This will need a refactor at some point. -->
<style>
  content a.internal-link {
    border-color: #8b88e6;
    background-color: #efefff;
  }

  #tooltip-wrapper {
    background: white;
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 4px;
    overflow: hidden;
    position: absolute;
    width: 400px;
    height: 250px;
    font-size: 0.8em;
    box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity 100ms;
  }

  #tooltip-wrapper:after {
		content: "";
		position: absolute;
		z-index: 1;
		bottom: 0;
		left: 0;
		pointer-events: none;
		background-image: linear-gradient(to bottom, rgba(255,255,255, 0), rgba(255,255,255, 1) 90%);
		width: 100%;
		height: 75px;
  }
</style>

<div style="opacity: 0; display: none;" id='tooltip-wrapper'>
  <div id='tooltip-content'>
  </div>
</div>

<iframe style="display: none; height: 0; width: 0;" id='link-preview-iframe' src="">
</iframe>

<script>
  var opacityTimeout;
  var contentTimeout;
  var transitionDurationMs = 100;

  var iframe = document.getElementById('link-preview-iframe')
  var tooltipWrapper = document.getElementById('tooltip-wrapper')
  var tooltipContent = document.getElementById('tooltip-content')

  var linkHistories = {};

  function hideTooltip() {
    opacityTimeout = setTimeout(function() {
      tooltipWrapper.style.opacity = 0;
      contentTimeout = setTimeout(function() {
        tooltipContent.innerHTML = '';
        tooltipWrapper.style.display = 'none';
      }, transitionDurationMs + 1);
    }, transitionDurationMs)
  }

  function showTooltip(event) {
    var elem = event.target;
    var elem_props = elem.getClientRects()[elem.getClientRects().length - 1];
    var top = window.pageYOffset || document.documentElement.scrollTop

    if (event.target.host === window.location.host) {
      if (!linkHistories[event.target.href]) {
        iframe.src = event.target.href
        iframe.onload = function() {
          tooltipContentHtml = ''
          tooltipContentHtml += '<div style="font-weight: bold;">' + iframe.contentWindow.document.querySelector('h1').innerHTML + '</div>'
          tooltipContentHtml += iframe.contentWindow.document.querySelector('content').innerHTML

          tooltipContent.innerHTML = tooltipContentHtml
          linkHistories[event.target.href] = tooltipContentHtml

          tooltipWrapper.style.display = 'block';
          setTimeout(function() {
            tooltipWrapper.style.opacity = 1;
          }, 1)
        } 
      } else {
        tooltipContent.innerHTML = linkHistories[event.target.href]
        tooltipWrapper.style.display = 'block';
        setTimeout(function() {
          tooltipWrapper.style.opacity = 1;
        }, 1)
      }


      tooltipWrapper.style.left = elem_props.left - (tooltipWrapper.offsetWidth / 2) + (elem_props.width / 2) + "px";
      if ((window.innerHeight - elem_props.top) < (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top - tooltipWrapper.offsetHeight - 10 + "px";
      } else if ((window.innerHeight - elem_props.top) > (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top + 35 + "px";
      }

      if ((elem_props.left + (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = "10px";
      } else if ((document.body.clientWidth - elem_props.left - (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = document.body.clientWidth - tooltipWrapper.offsetWidth - 20 + "px";
      }
    }
  }

  function setupListeners(linkElement) {
    linkElement.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
      showTooltip(event);
    });

    tooltipWrapper.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
    });
  }

  document.querySelectorAll('content a').forEach(setupListeners);
</script>

  </body>
</html>
