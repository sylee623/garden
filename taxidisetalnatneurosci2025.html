<!DOCTYPE html>
<html lang="en">
  <body>
    <nav><div>
    <a class="internal-link" href="/garden/"><b>Seoyeon Lee</b></a>
</div>
</nav>
    <div class="wrapper">
      <main><article>
  <div>
    <h1>Voltage imaging reveals hippocampal inhibitory dynamics shaping pyramidal memory-encoding sequences</h1>
    <time datetime="2025-08-07T19:26:26+09:00">
      Last updated on August 7, 2025
      
    </time>
  </div>

  <div id="notes-entry-container">
    <content>
      <h2 id="summary">Summary</h2>
<h3 id="논문-정보">논문 정보</h3>
<ul>
  <li>
<strong>교신저자</strong>: Jiannis Taxidis (The Hospital for Sick Children, University of Toronto), Peyman Golshani (UCLA, neuroscience, memory circuits)</li>
  <li>
<strong>소속</strong>: UCLA, Stanford, SickKids, MIT 등</li>
</ul>

<h3 id="tldr-">TL;DR 🧠</h3>

<h3 id="연구-배경-및-목적">연구 배경 및 목적</h3>

<ul>
  <li>Hippocampus는 경험을 시퀀스로 구성해 기억화하는 핵심 뇌 역이며, 특히 CA1의 hippocampal pyramidal neuron들이 sensory cue 및 시간 정보를 encoding하는 역할을 한다. 이러한</li>
  <li>시퀀스는 excitatory-inhibitory balance 위에서 형성되지만, <mark>inhibitory interneuron</mark>—특히 parvalbumin (PV)과 somatostatin (SST)을 발현하는 subtype—의 구체적 기여는 명확히 규명되지 않았다.</li>
  <li>이 논문은 <mark>in vivo voltage imaging</mark>을 이용해 이들 interneuron의 고속 dynamics를 추적하고, working memory task에서의 기능을 분석한다.</li>
</ul>

<h3 id="주요-발견-highlights">주요 발견 (Highlights)</h3>

<ul>
  <li>
<strong>odor cue가 주어질 때</strong>, PV와 SST inhibitory interneuron은 <strong>odor identity나 delay time에 특이적이지 않은 broad spiking</strong>을 보임.</li>
  <li>odor onset 직후, PV interneuron의 <strong>짧은 burst spiking이</strong> 전체 inhibitory interneuron의 <strong>synchronized hyperpolarization과 theta phase reset</strong>을 유도함.</li>
  <li>이 시점의 inhibition은 대부분의 hippocampal pyramidal neuron을 억제하고, <strong>소수의 odor-selective neuron만 rebound spiking을 통해 firing</strong>하게 해줌.</li>
  <li>PV interneuron은 pyramidal neuron의 spiking을 직접 억제하고, SST interneuron은 다른 interneuron을 억제함으로써 <strong>disinhibitory control</strong>을 담당함.</li>
  <li>
<strong>interneuron의 field activity는 학습 여부와 관계없이 일정하며</strong>, 각 세포의 firing 특성은 하루 단위로 바뀔 수 있음.</li>
</ul>

<h3 id="methods">Methods</h3>

<ul>
  <li>
<strong>Model</strong>: PV-Cre, SST-Cre mouse line (각 5마리)</li>
  <li>
<strong>Voltage imaging</strong>: ASAP3 및 ASAP4 GEVI 사용, 1,000 fps로 CA1의 inhibitory interneuron 활동 기록</li>
  <li>
<strong>Behavioral paradigm</strong>: DNMS (delayed non-match-to-sample) odor task, head-fixed condition</li>
  <li>
<strong>보조 기법</strong>:
    <ul>
      <li>Neuropixels spike recording (putative pyramidal cell 및 interneuron 구분)</li>
      <li>Optogenetic suppression using soma-targeted GtACR2</li>
      <li>Two-photon calcium imaging (GCaMP6f)</li>
    </ul>
  </li>
</ul>

<h3 id="results">Results</h3>

<h4 id="in-vivo-voltage-imaging-of-pv-and-sst-cells-during-dnms">In vivo voltage imaging of PV and SST cells during DNMS</h4>
<ul>
  <li>ASAP3로 spiking과 subthreshold membrane potential을 동시에 포착</li>
  <li>PV는 SST보다 높은 burst index, theta modulation, spiking rate 보임</li>
</ul>

<h4 id="pvsst-cells-encode-odor-delivery-not-odor-identity-or-delay-time">PV–SST cells encode odor delivery, not odor identity or delay time</h4>
<ul>
  <li>대부분의 PV/SST 세포는 odor 자극이 있을 때 firing하지만, <strong>odor A/B에 대한 selectivity는 거의 없음</strong>
</li>
  <li>delay 기간에는 매우 sparse한 firing field만 존재함 → time coding은 하지 않음</li>
</ul>

<h4 id="steady-state-inhibition-across-days-independent-of-training">Steady-state inhibition across days independent of training</h4>
<ul>
  <li>PV/SST 세포의 field 수, odor selectivity는 학습과 무관하게 일정</li>
  <li>개별 세포의 field는 날마다 변하지만 전체 억제 규모는 유지됨</li>
</ul>

<h4 id="pvsst-hyperpolarization-at-odor-onset-resets-intracellular-theta">PV–SST hyperpolarization at odor onset resets intracellular theta</h4>
<ul>
  <li>odor 시작 시, PV와 SST 세포 모두에서 de-spiked ΔF/F가 음의 방향으로 크게 꺾이는 hyperpolarization 발생</li>
  <li>이 event는 trial마다 있는 것은 아니며, <strong>theta phase reset과 동반됨</strong>
</li>
</ul>

<h4 id="hyperpolarization-is-preceded-by-pv-spiking-and-synchronizes-rebound-theta-spiking">Hyperpolarization is preceded by PV spiking and synchronizes rebound theta spiking</h4>
<ul>
  <li>hyperpolarization은 odor 시작 직후의 PV burst spiking으로 유도됨</li>
  <li>이후 theta 주기와 동기화된 rebound spiking이 PV 및 SST에서 발생 → interneuron 사이에 theta coherence 유도</li>
</ul>

<h4 id="pv-interneurons-suppress-most-pyramidal-cells-during-odors">PV interneurons suppress most pyramidal cells during odors</h4>
<ul>
  <li>Neuropixels 및 optogenetic suppression 실험에서, PV inhibition이 대부분의 hippocampal pyramidal neuron을 odor 동안 억제함을 확인</li>
  <li>SST 억제는 다른 interneuron의 spiking을 증가시키며 disinhibitory 효과 유발</li>
</ul>

<h4 id="inhibition-coordinates-odor-cell-and-time-cell-spiking">Inhibition coordinates odor-cell and time-cell spiking</h4>
<ul>
  <li>odor-excited pyramidal neuron은 <mark>hyperpolarization 전에 spike를 내는 **early spiking group**과</mark> <mark>rebound 시점에 spike를 내는 **late spiking group**</mark>으로 나뉨</li>
  <li>대부분의 time cell은 odor 자극 시 억제되고, delay 기간 동안 활성화됨</li>
  <li>이러한 경향은 calcium imaging 데이터셋에서도 재현됨</li>
</ul>

<h3 id="discussion-요약">Discussion 요약</h3>
<ul>
  <li>PV/SST inhibitory interneuron은 <strong>odor cue 발생 시점에 강하게 활성화되어 hippocampal pyramidal neuron의 background activity를 억제</strong>함으로써, odor cue에 selective한 neuron들의 spiking을 강조하고, <strong>signal-to-noise ratio를 향상</strong>시킴</li>
  <li>이는 encoding 시점에서는 inhibition이 필요하지만, delay 기간 동안의 maintenance에는 관여하지 않는 <strong>temporal gating 역할</strong>을 수행함</li>
  <li>interneuron의 ensemble은 매일 다른 세포로 구성되며, 고정된 spiking pattern이 아닌 <strong>dynamic inhibition</strong>을 구현함</li>
  <li>hyperpolarization의 기원은 medial septum, entorhinal cortex, 혹은 VIP-mediated disinhibition 등 다양한 가능성이 제시됨</li>
  <li>향후 연구는 PV와 SST 내부의 세부 subtype 간 차이, 그리고 다세포 voltage imaging을 통한 <strong>population-level inhibitory dynamics</strong> 분석으로 확장될 수 있음</li>
</ul>

<h2 id="related-article">Related Article</h2>

<h2 id="abstract">Abstract</h2>
<blockquote>
  <p>[!Abstract]
Hippocampal spiking sequences encode and link behaviorally relevant information across time. How inhibition sculpts these sequences remains unclear. We performed longitudinal voltage imaging of CA1 parvalbumin- and somatostatin-expressing interneurons in mice performing an odor-cued working memory task. Unlike pyramidal odor-specific sequences that encode odor and time throughout a delay period, interneurons encoded odor delivery, but not odor identity or delay time. Odor-triggered inhibition was exerted by stable numbers of interneurons across days, with constant cell turnover, independent of task training. At odor onset, brief spiking of parvalbumin interneurons was followed by widespread hyperpolarization and synchronized theta-paced rebound spiking across interneurons. Electrophysiology, optogenetics and calcium imaging corroborated that parvalbumin interneurons silenced most pyramidal cells during odor delivery, whereas somatostatin interneurons suppressed other interneurons. The few odor-selective pyramidal cells spiked together with interneuronal post-hyperpolarization rebound. Collectively, inhibition increases the signal-to-noise ratio of pyramidal cue representations, enabling efficient encoding of memory-relevant information.<mark>=  
</mark>&gt;.<mark>=  
</mark>&gt;</p>
</blockquote>

      <p>This line appears after every note.</p>
    </content>

    <side style="font-size: 0.9em">
      <h3 style="margin-bottom: 1em">Notes mentioning this note</h3>
      

      <div style="font-size: 0.9em">
        <p>
          There are no notes linking to this note.
        </p>
      </div>
      
    </side>
  </div>
</article>

<hr>

<p>Here are all the notes in this garden, along with their links, visualized as a graph.</p>

<style>
  .links line {
    stroke: #ccc;
    opacity: 0.5;
  }

  .nodes circle {
    cursor: pointer;
    fill: #8b88e6;
    transition: all 0.15s ease-out;
  }

  .text text {
    cursor: pointer;
    fill: #333;
    text-shadow: -1px -1px 0 #fafafabb, 1px -1px 0 #fafafabb, -1px 1px 0 #fafafabb, 1px 1px 0 #fafafabb;
  }

  .nodes [active],
  .text [active] {
    cursor: pointer;
    fill: black;
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper {
    background: #fcfcfc;
    border-radius: 4px;
    height: auto;
  }
  
  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      oScript.onload = () => {
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 12;
        const ACTIVE_RADIUS_FACTOR = 1.5;
        const STROKE = 1;
        const FONT_SIZE = 16;
        const TICKS = 200;
        const FONT_BASELINE = 40;
        const MAX_LABEL_LENGTH = 50;

        const graphData = {"edges":[{"source":"891111171143210210511411511632115101101100","target":"66111110329711211219516911610511633"},{"source":"891111171143210210511411511632115101101100","target":"6532110111116101329798111117116329997116115"},{"source":"891111171143210210511411511632115101101100","target":"84105103101114115"},{"source":"77111118101321211111171143298111100121321011181011141213210097121","target":"67111110115105115116101110991213210511532107101121"},{"source":"6532110111116101329798111117116329997116115","target":"77111118101321211111171143298111100121321011181011141213210097121"},{"source":"67111110115105115116101110991213210511532107101121","target":"891111171143210210511411511632115101101100"},{"source":"891111171143210210511411511632115101101100","target":"236149136235133149237149152236132184236154148"}],"nodes":[{"id":"66111110329711211219516911610511633","path":"/garden/accents","label":"Bon appétit!"},{"id":"6532110111116101329798111117116329997116115","path":"/garden/cats","label":"A note about cats"},{"id":"84105103101114115","path":"/garden/tigers","label":"Tigers"},{"id":"67111110115105115116101110991213210511532107101121","path":"/garden/consistency","label":"Consistency is key"},{"id":"77111118101321211111171143298111100121321011181011141213210097121","path":"/garden/move-your-body-every-day","label":"Move your body every day"},{"id":"7797110117115991141051121169511611111697108","path":"/garden/manuscript-total","label":"Manuscript_total"},{"id":"6510010010511610511111097108329711097108121115105115","path":"/garden/additional-analysis","label":"Additional analysis"},{"id":"50534855514895102114111109951151041141051091129511611195100111108112104105110","path":"/garden/250730-from-shrimp-to-dolphin","label":"250730_from_shrimp_to_dolphin"},{"id":"123123116105116108101125125","path":"/garden/journal-summary","label":""},{"id":"7311010010511810510011797108321001051021021011141011109910111532105110321001019910511510511111045109971071051101033211510497112101321041111193210910111511110810510998105993210011111297109105110101321141011031171089711610111532991041111059910132991111101021051001011109910132971101003299104971101031014511110245109105110100","path":"/garden/kocharianetalnatneurosci2025","label":"Individual differences in decision-making shape how mesolimbic dopamine regulates choice confidence and change-of-mind"},{"id":"65321021081011201059810810132104105112112111999710911297108321121111121171089711610511111032991111001013210211111432101120112101114105101110991013211410110897116105118101321161113211410111997114100","path":"/garden/sosaetalnatneurosci2025","label":"A flexible hippocampal population code for experience relative to reward"},{"id":"86111108116971031013210510997103105110103321141011181019710811532104105112112111999710911297108321051101041059810511611111412132100121110971091059911532115104971121051101033211212111497109105100971083210910110911111412145101110991111001051101033211510111311710111099101115","path":"/garden/taxidisetalnatneurosci2025","label":"Voltage imaging reveals hippocampal inhibitory dynamics shaping pyramidal memory-encoding sequences"},{"id":"6511032105110116101103114971161011003211510511010310810145110117991081011171153297110100321151129711610597108321161149711011599114105112116111109105991153297116108971153211410111810197108115321161041013210911110810199117108971143210897110100115999711210132111102321161041013210411710997110321041051121121119997109112117115","path":"/garden/thompsonetalnatneurosci2025","label":"An integrated single-nucleus and spatial transcriptomics atlas reveals the molecular landscape of the human hippocampus"},{"id":"78101117114971083297110116105991051129711610511111032111102321181051141161179710832105110102101991161051111103211611410510310310111411532971103210510910911711010132114101115112111110115101","path":"/garden/trabanellietalnatneurosci2025a","label":"Neural anticipation of virtual infection triggers an immune response"},{"id":"8710110899111109101","path":"/garden/welcome","label":"Welcome"},{"id":"891111171143210210511411511632115101101100","path":"/garden/your-first-note","label":"Your first seed"},{"id":"236149136235133149237149152236132184236154148","path":"/garden/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94","label":"안녕하세요"}]}
        let nodesData = graphData.nodes;
        let linksData = graphData.edges;

        const nodeSize = {};

        const updateNodeSize = () => {
          nodesData.forEach((el) => {
            let weight =
              3 *
              Math.sqrt(
                linksData.filter((l) => l.source.id === el.id || l.target.id === el.id)
                  .length + 1
              );
            if (weight < MINIMAL_NODE_SIZE) {
              weight = MINIMAL_NODE_SIZE;
            } else if (weight > MAX_NODE_SIZE) {
              weight = MAX_NODE_SIZE;
            }
            nodeSize[el.id] = weight;
          });
        };

        const onClick = (d) => {
          window.location = d.path
        };

        const onMouseover = function (d) {
          const relatedNodesSet = new Set();
          linksData
            .filter((n) => n.target.id == d.id || n.source.id == d.id)
            .forEach((n) => {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", (node_d) => {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", (link_d) => {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", (link_d) => {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 4;
            }
            return STROKE;
          });
          text.attr("class", (text_d) => {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        };

        const onMouseout = function (d) {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        };

        const sameNodes = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const map = new Map();
          for (const node of previous) {
            map.set(node.id, node.label);
          }

          for (const node of next) {
            const found = map.get(node.id);
            if (!found || found !== node.title) {
              return false;
            }
          }

          return true;
        };

        const sameEdges = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const set = new Set();
          for (const edge of previous) {
            set.add(`${edge.source.id}-${edge.target.id}`);
          }

          for (const edge of next) {
            if (!set.has(`${edge.source.id}-${edge.target.id}`)) {
              return false;
            }
          }

          return true;
        };

        const graphWrapper = document.getElementById('graph-wrapper')
        const element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        element.setAttribute("width", graphWrapper.getBoundingClientRect().width);
        element.setAttribute("height", window.innerHeight * 0.8);
        graphWrapper.appendChild(element);

        const reportWindowSize = () => {
          element.setAttribute("width", window.innerWidth);
          element.setAttribute("height", window.innerHeight);
        };

        window.onresize = reportWindowSize;

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));
        let zoomLevel = 1;

        const simulation = d3
          .forceSimulation(nodesData)
          .force("forceX", d3.forceX().x(width / 2))
          .force("forceY", d3.forceY().y(height / 2))
          .force("charge", d3.forceManyBody())
          .force(
            "link",
            d3
              .forceLink(linksData)
              .id((d) => d.id)
              .distance(70)
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(80))
          .stop();

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const resize = () => {
          if (d3.event) {
            const scale = d3.event.transform;
            zoomLevel = scale.k;
            g.attr("transform", scale);
          }

          const zoomOrKeep = (value) => (zoomLevel >= 1 ? value / zoomLevel : value);

          const font = Math.max(Math.round(zoomOrKeep(FONT_SIZE)), 1);

          text.attr("font-size", (d) => font);
          text.attr("y", (d) => d.y - zoomOrKeep(FONT_BASELINE) + 8);
          link.attr("stroke-width", zoomOrKeep(STROKE));
          node.attr("r", (d) => {
            return zoomOrKeep(nodeSize[d.id]);
          });
          svg
            .selectAll("circle")
            .filter((_d, i, nodes) => d3.select(nodes[i]).attr("active"))
            .attr("r", (d) => zoomOrKeep(ACTIVE_RADIUS_FACTOR * nodeSize[d.id]));
        };

        const ticked = () => {
          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          text
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - (FONT_BASELINE - nodeSize[d.id]) / zoomLevel);
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        };

        const restart = () => {
          updateNodeSize();
          node = node.data(nodesData, (d) => d.id);
          node.exit().remove();
          node = node
            .enter()
            .append("circle")
            .attr("r", (d) => {
              return nodeSize[d.id];
            })
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(node);

          link = link.data(linksData, (d) => `${d.source.id}-${d.target.id}`);
          link.exit().remove();
          link = link.enter().append("line").attr("stroke-width", STROKE).merge(link);

          text = text.data(nodesData, (d) => d.label);
          text.exit().remove();
          text = text
            .enter()
            .append("text")
            .text((d) => shorten(d.label.replace(/_*/g, ""), MAX_LABEL_LENGTH))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

          node.attr("active", (d) => isCurrentPath(d.path) ? true : null);
          text.attr("active", (d) => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);
          simulation.alpha(1).restart();
          simulation.stop();

          for (let i = 0; i < TICKS; i++) {
            simulation.tick();
          }

          ticked();
        };

        const zoomHandler = d3.zoom().scaleExtent([0.2, 3]).on("zoom", resize);

        zoomHandler(svg);
        restart();

        function isCurrentPath(notePath) {
          return window.location.pathname.includes(notePath)
        }

        function shorten(str, maxLen, separator = ' ') {
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
      }
    }
  </script>
</div>

</main>
      <footer>


  <footer class="sticky-bottom mt-5" role="contentinfo">
    

    <div class="container">
      
  &copy; Copyright 2025
  Seoyeon
  
  Lee. 
  
  

    </div>
  </footer>

</footer>
    </div>

    <!-- That file is not particularly elegant. This will need a refactor at some point. -->
<style>
  content a.internal-link {
    border-color: #8b88e6;
    background-color: #efefff;
  }

  #tooltip-wrapper {
    background: white;
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 4px;
    overflow: hidden;
    position: absolute;
    width: 400px;
    height: 250px;
    font-size: 0.8em;
    box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity 100ms;
  }

  #tooltip-wrapper:after {
		content: "";
		position: absolute;
		z-index: 1;
		bottom: 0;
		left: 0;
		pointer-events: none;
		background-image: linear-gradient(to bottom, rgba(255,255,255, 0), rgba(255,255,255, 1) 90%);
		width: 100%;
		height: 75px;
  }
</style>

<div style="opacity: 0; display: none;" id='tooltip-wrapper'>
  <div id='tooltip-content'>
  </div>
</div>

<iframe style="display: none; height: 0; width: 0;" id='link-preview-iframe' src="">
</iframe>

<script>
  var opacityTimeout;
  var contentTimeout;
  var transitionDurationMs = 100;

  var iframe = document.getElementById('link-preview-iframe')
  var tooltipWrapper = document.getElementById('tooltip-wrapper')
  var tooltipContent = document.getElementById('tooltip-content')

  var linkHistories = {};

  function hideTooltip() {
    opacityTimeout = setTimeout(function() {
      tooltipWrapper.style.opacity = 0;
      contentTimeout = setTimeout(function() {
        tooltipContent.innerHTML = '';
        tooltipWrapper.style.display = 'none';
      }, transitionDurationMs + 1);
    }, transitionDurationMs)
  }

  function showTooltip(event) {
    var elem = event.target;
    var elem_props = elem.getClientRects()[elem.getClientRects().length - 1];
    var top = window.pageYOffset || document.documentElement.scrollTop

    if (event.target.host === window.location.host) {
      if (!linkHistories[event.target.href]) {
        iframe.src = event.target.href
        iframe.onload = function() {
          tooltipContentHtml = ''
          tooltipContentHtml += '<div style="font-weight: bold;">' + iframe.contentWindow.document.querySelector('h1').innerHTML + '</div>'
          tooltipContentHtml += iframe.contentWindow.document.querySelector('content').innerHTML

          tooltipContent.innerHTML = tooltipContentHtml
          linkHistories[event.target.href] = tooltipContentHtml

          tooltipWrapper.style.display = 'block';
          setTimeout(function() {
            tooltipWrapper.style.opacity = 1;
          }, 1)
        } 
      } else {
        tooltipContent.innerHTML = linkHistories[event.target.href]
        tooltipWrapper.style.display = 'block';
        setTimeout(function() {
          tooltipWrapper.style.opacity = 1;
        }, 1)
      }


      tooltipWrapper.style.left = elem_props.left - (tooltipWrapper.offsetWidth / 2) + (elem_props.width / 2) + "px";
      if ((window.innerHeight - elem_props.top) < (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top - tooltipWrapper.offsetHeight - 10 + "px";
      } else if ((window.innerHeight - elem_props.top) > (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top + 35 + "px";
      }

      if ((elem_props.left + (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = "10px";
      } else if ((document.body.clientWidth - elem_props.left - (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = document.body.clientWidth - tooltipWrapper.offsetWidth - 20 + "px";
      }
    }
  }

  function setupListeners(linkElement) {
    linkElement.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
      showTooltip(event);
    });

    tooltipWrapper.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
    });
  }

  document.querySelectorAll('content a').forEach(setupListeners);
</script>

  </body>
</html>
