<!DOCTYPE html>
<html lang="en">
  <body>
    <nav><div>
    <a class="internal-link" href="/garden/"><b>Seoyeon Lee</b></a>
</div>
</nav>
    <div class="wrapper">
      <main><article>
  <div>
    <h1>Individual differences in decision-making shape how mesolimbic dopamine regulates choice confidence and change-of-mind</h1>
    <time datetime="2025-08-07T19:26:26+09:00">
      Last updated on August 7, 2025
      
    </time>
  </div>

  <div id="notes-entry-container">
    <content>
      <h2 id="summary">Summary</h2>
<h3 id="저자-정보">저자 정보</h3>
<p>교신저자: Patrick E. Rothwell<br>
소속: University of Minnesota Medical School, Department of Neuroscience<br>
주요 연구 분야: mesolimbic dopamine, motivated behavior, decision-making</p>

<h3 id="tldr">TL;DR</h3>
<p>개체 간의 decision-making 차이는 mesolimbic dopamine이 choice confidence와 change-of-mind를 조절하는 방식을 결정한다.</p>

<h3 id="background">Background</h3>
<ul>
  <li>dopamine은 오랫동안 <mark>reward prediction error(RPE)</mark>를 중심으로 연구되어 왔으나, 실제 자연 환경의 decision-making은 평가와 재평가를 포함한 <mark>연속적인 과정</mark>이다.</li>
  <li>이 연구는 mesolimbic dopamine이 자발적인 change-of-mind 및 decision confidence에 어떻게 관여하는지, 그리고 이러한 신경 신호가 개체의 offer sensitivity에 따라 달라지는지를 규명하고자 한다.
,
    <h3 id="주요-발견">주요 발견</h3>
  </li>
  <li>
<span title="There is no note that matches this link." class="invalid-link">  <span class="invalid-link-brackets">[[</span>  Nucleus accumbens(NAc)  <span class="invalid-link-brackets">]]</span></span> core의 dopamine 신호는 <strong>evaluation 시 decision confidence를</strong>, <strong>re-evaluation 시 과거 가치(past value)와 미래 가치(future value)를 반영</strong>한다.</li>
  <li>모든 마우스에서 <mark>**change-of-mind(=quit) 직전에 dopamine dip이 발생**</mark>하였으며, 이 신호는 internally generated re-evaluation과 관련된다.</li>
  <li>offer-sensitive 개체에서만 optogenetic inhibition이 change-of-mind 행동을 유의하게 증가시켰다.</li>
  <li>optogenetic stimulation은 decision confidence를 높이고 subsequent change-of-mind를 감소시켰다.</li>
  <li>dopamine dynamics는 개체의 decision-making phenotype에 따라 평가 또는 재평가 단계에서 다르게 작동한다.</li>
</ul>

<h3 id="methods">Methods</h3>

<ul>
  <li>마우스는 Restaurant Row라는 self-paced sequential foraging task에서 다양한 flavor의 pellet 보상을 받음.</li>
  <li>제안(offer)의 대기 시간(delay)에 따라 행동을 조절하는 정도로 마우스를 offer-sensitive와 offer-insensitive로 분류 (Gaussian mixture model 기반).</li>
  <li>mesolimbic dopamine activity는 <mark>dLight1.3b 기반 fiber photometry로</mark> NAc core에서 측정.</li>
  <li>VTA dopamine neuron에 ChrimsonR 또는 eNpHR3.0을 발현시켜 optogenetic stimulation 및 inhibition 수행.</li>
  <li>decision-making 과정에서 VTE, zIdPhi, reaction time, skip/quit 비율 등을 behavioral readout으로 활용.</li>
</ul>

<h3 id="figure별-요약">Figure별 요약</h3>

<h4 id="평가-행동의-개발-fig-1">평가 행동의 개발 (Fig. 1)</h4>
<ul>
  <li>training을 거치며 skip 비율 증가, quit 비율 감소, 총 pellet 획득량 증가.</li>
  <li>skip과 quit 후 다음 레스토랑에서의 행동 차이로 <mark>evaluation과 re-evaluation이 분리</mark>됨.</li>
</ul>

<h4 id="개체-간-offer-sensitivity-차이-fig-2">개체 간 offer sensitivity 차이 (Fig. 2)</h4>
<ul>
  <li>offer-sensitive 개체는 <strong>delay에 따라 행동을 유의하게 조절</strong>하며 threshold를 점진적으로 학습함.</li>
  <li>offer-insensitive 개체는 <strong>행동이 delay에 무관</strong>하거나 flavor preference에 의존적임.</li>
</ul>

<h4 id="dopamine-신호와-phenotype의-연관-fig-3">dopamine 신호와 phenotype의 연관 (Fig. 3)</h4>
<ul>
  <li>offer-sensitive 개체는 <strong>accept 시 dopamine 상승, skip 시 감소</strong> → decision confidence 반영.</li>
  <li>wait zone에서는 earn 시 dopamine 증가, quit 직전에는 dip 발생.</li>
</ul>

<h4 id="re-evaluation과-past-value의-반영-fig-4">re-evaluation과 past value의 반영 (Fig. 4)</h4>
<ul>
  <li>quit 이후 dopamine rebound는 <strong>과거 가치(past value)에 반비례</strong>.</li>
  <li>skip에서는 이런 rebound가 관찰되지 않음.</li>
</ul>

<h4 id="future-value와-dopamine-dip-fig-5">future value와 dopamine dip (Fig. 5)</h4>
<ul>
  <li>offer-sensitive 개체는 economically favorable한 quit에서 <strong>더 깊은 dopamine dip이 나타남</strong>.</li>
  <li>offer-insensitive 개체에서는 이러한 차이가 없음.</li>
</ul>

<h4 id="optogenetic-inhibition의-효과-fig-6">optogenetic inhibition의 효과 (Fig. 6)</h4>
<ul>
  <li>dopamine 억제는 <strong>offer-sensitive 개체에서만 quit 확률을 증가</strong>시킴.</li>
  <li>이는 <strong>dopamine dip이 change-of-mind를 유발할 수 있음</strong>을 시사.
    <ul>
      <li>==Dopamine dip 을 의도적으로 일으켰을때 결정을 바꿨다.==</li>
    </ul>
  </li>
</ul>

<h4 id="decision-confidence와-vte-fig-7">decision confidence와 VTE (Fig. 7)</h4>
<ul>
  <li>VTE(zIdPhi↑)가 높을수록 decision confidence는 낮으며 dopamine peak는 작음.</li>
  <li>이러한 관계는 offer-sensitive 개체에서만 뚜렷하게 관찰됨.</li>
</ul>

<h4 id="dopamine-stimulation의-효과-fig-8">dopamine stimulation의 효과 (Fig. 8)</h4>
<ul>
  <li>optogenetic stimulation은 VTE를 줄이고 decision confidence를 증가시킴.</li>
  <li>stimulation은 wait zone 진입 이후에도 quit 확률을 감소시켜, prior confidence의 carryover effect를 보임.</li>
</ul>

<h3 id="discussion-요약">Discussion 요약</h3>
<ul>
  <li>decision-making은 discrete choice가 아니라 evaluation과 re-evaluation을 포함한 연속적 과정이며, dopamine은 그 전 과정에 걸쳐 정보 신호를 제공함.</li>
  <li>offer-sensitive 개체에서 dopamine dip은 <strong>future value에 기반한 re-evaluation과 연결</strong>되어 있으며, change-of-mind는 dopamine 억제에 의해 유도될 수 있음.</li>
  <li>dopamine stimulation은 decision confidence를 증폭시켜 change-of-mind 행동을 줄임.</li>
  <li>기존의 temporal difference reinforcement learning (TDRL) 모델은 <strong>actual outcome과 expected value만을 고려하므로, 본 연구는 counterfactual value와 regret을 포함한 확장된 프레임워크</strong>를 제안함.</li>
  <li>mesolimbic dopamine의 기능은 개체의 행동 전략에 따라 달라지며, 이는 정신질환에서의 개체 간 차이를 설명할 수 있는 실마리가 됨.</li>
</ul>

<h2 id="related-article">Related Article</h2>

<h2 id="abstract">Abstract</h2>
<blockquote>
  <p>[!Abstract]
Nucleus accumbens dopamine signaling is an important neural substrate for decision-making. Dominant theories generally discretize and homogenize decision-making, when it is in fact a continuous process, with evaluation and re-evaluation components that extend beyond simple outcome prediction into consideration of past and future value. Extensive work has examined mesolimbic dopamine in the context of reward prediction error, but major gaps persist in our understanding of how dopamine regulates volitional and self-guided decision-making. Moreover, there is little consideration of individual differences in value processing that may shape how dopamine regulates decision-making. Here, using an economic foraging task in mice, we found that dopamine dynamics in the nucleus accumbens core reflected decision confidence during evaluation of decisions as well as both past and future value during re-evaluation and change-of-mind. Optogenetic manipulations of mesolimbic dopamine release selectively altered evaluation and re-evaluation of decisions in mice whose dopamine dynamics and behavior reflected future value.<mark>=  
</mark>&gt;.<mark>=  
</mark>&gt;</p>
</blockquote>

      <p>This line appears after every note.</p>
    </content>

    <side style="font-size: 0.9em">
      <h3 style="margin-bottom: 1em">Notes mentioning this note</h3>
      

      <div style="font-size: 0.9em">
        <p>
          There are no notes linking to this note.
        </p>
      </div>
      
    </side>
  </div>
</article>

<hr>

<p>Here are all the notes in this garden, along with their links, visualized as a graph.</p>

<style>
  .links line {
    stroke: #ccc;
    opacity: 0.5;
  }

  .nodes circle {
    cursor: pointer;
    fill: #8b88e6;
    transition: all 0.15s ease-out;
  }

  .text text {
    cursor: pointer;
    fill: #333;
    text-shadow: -1px -1px 0 #fafafabb, 1px -1px 0 #fafafabb, -1px 1px 0 #fafafabb, 1px 1px 0 #fafafabb;
  }

  .nodes [active],
  .text [active] {
    cursor: pointer;
    fill: black;
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper {
    background: #fcfcfc;
    border-radius: 4px;
    height: auto;
  }
  
  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      oScript.onload = () => {
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 12;
        const ACTIVE_RADIUS_FACTOR = 1.5;
        const STROKE = 1;
        const FONT_SIZE = 16;
        const TICKS = 200;
        const FONT_BASELINE = 40;
        const MAX_LABEL_LENGTH = 50;

        const graphData = {"edges":[],"nodes":[{"id":"6532110111116101329798111117116329997116115","path":"/garden/cats","label":"A note about cats"},{"id":"84105103101114115","path":"/garden/tigers","label":"Tigers"},{"id":"7797110117115991141051121169511611111697108","path":"/garden/manuscript-total","label":"Manuscript_total"},{"id":"6510010010511610511111097108329711097108121115105115","path":"/garden/additional-analysis","label":"Additional analysis"},{"id":"50534855514895102114111109951151041141051091129511611195100111108112104105110","path":"/garden/250730-from-shrimp-to-dolphin","label":"250730_from_shrimp_to_dolphin"},{"id":"123123116105116108101125125","path":"/garden/journal-summary","label":""},{"id":"7311010010511810510011797108321001051021021011141011109910111532105110321001019910511510511111045109971071051101033211510497112101321041111193210910111511110810510998105993210011111297109105110101321141011031171089711610111532991041111059910132991111101021051001011109910132971101003299104971101031014511110245109105110100","path":"/garden/kocharianetalnatneurosci2025","label":"Individual differences in decision-making shape how mesolimbic dopamine regulates choice confidence and change-of-mind"},{"id":"65321021081011201059810810132104105112112111999710911297108321121111121171089711610511111032991111001013210211111432101120112101114105101110991013211410110897116105118101321161113211410111997114100","path":"/garden/sosaetalnatneurosci2025","label":"A flexible hippocampal population code for experience relative to reward"},{"id":"86111108116971031013210510997103105110103321141011181019710811532104105112112111999710911297108321051101041059810511611111412132100121110971091059911532115104971121051101033211212111497109105100971083210910110911111412145101110991111001051101033211510111311710111099101115","path":"/garden/taxidisetalnatneurosci2025","label":"Voltage imaging reveals hippocampal inhibitory dynamics shaping pyramidal memory-encoding sequences"},{"id":"6511032105110116101103114971161011003211510511010310810145110117991081011171153297110100321151129711610597108321161149711011599114105112116111109105991153297116108971153211410111810197108115321161041013210911110810199117108971143210897110100115999711210132111102321161041013210411710997110321041051121121119997109112117115","path":"/garden/thompsonetalnatneurosci2025","label":"An integrated single-nucleus and spatial transcriptomics atlas reveals the molecular landscape of the human hippocampus"},{"id":"78101117114971083297110116105991051129711610511111032111102321181051141161179710832105110102101991161051111103211611410510310310111411532971103210510910911711010132114101115112111110115101","path":"/garden/trabanellietalnatneurosci2025a","label":"Neural anticipation of virtual infection triggers an immune response"},{"id":"8710110899111109101","path":"/garden/welcome","label":"Welcome"}]}
        let nodesData = graphData.nodes;
        let linksData = graphData.edges;

        const nodeSize = {};

        const updateNodeSize = () => {
          nodesData.forEach((el) => {
            let weight =
              3 *
              Math.sqrt(
                linksData.filter((l) => l.source.id === el.id || l.target.id === el.id)
                  .length + 1
              );
            if (weight < MINIMAL_NODE_SIZE) {
              weight = MINIMAL_NODE_SIZE;
            } else if (weight > MAX_NODE_SIZE) {
              weight = MAX_NODE_SIZE;
            }
            nodeSize[el.id] = weight;
          });
        };

        const onClick = (d) => {
          window.location = d.path
        };

        const onMouseover = function (d) {
          const relatedNodesSet = new Set();
          linksData
            .filter((n) => n.target.id == d.id || n.source.id == d.id)
            .forEach((n) => {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", (node_d) => {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", (link_d) => {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", (link_d) => {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 4;
            }
            return STROKE;
          });
          text.attr("class", (text_d) => {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        };

        const onMouseout = function (d) {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        };

        const sameNodes = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const map = new Map();
          for (const node of previous) {
            map.set(node.id, node.label);
          }

          for (const node of next) {
            const found = map.get(node.id);
            if (!found || found !== node.title) {
              return false;
            }
          }

          return true;
        };

        const sameEdges = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const set = new Set();
          for (const edge of previous) {
            set.add(`${edge.source.id}-${edge.target.id}`);
          }

          for (const edge of next) {
            if (!set.has(`${edge.source.id}-${edge.target.id}`)) {
              return false;
            }
          }

          return true;
        };

        const graphWrapper = document.getElementById('graph-wrapper')
        const element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        element.setAttribute("width", graphWrapper.getBoundingClientRect().width);
        element.setAttribute("height", window.innerHeight * 0.8);
        graphWrapper.appendChild(element);

        const reportWindowSize = () => {
          element.setAttribute("width", window.innerWidth);
          element.setAttribute("height", window.innerHeight);
        };

        window.onresize = reportWindowSize;

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));
        let zoomLevel = 1;

        const simulation = d3
          .forceSimulation(nodesData)
          .force("forceX", d3.forceX().x(width / 2))
          .force("forceY", d3.forceY().y(height / 2))
          .force("charge", d3.forceManyBody())
          .force(
            "link",
            d3
              .forceLink(linksData)
              .id((d) => d.id)
              .distance(70)
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(80))
          .stop();

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const resize = () => {
          if (d3.event) {
            const scale = d3.event.transform;
            zoomLevel = scale.k;
            g.attr("transform", scale);
          }

          const zoomOrKeep = (value) => (zoomLevel >= 1 ? value / zoomLevel : value);

          const font = Math.max(Math.round(zoomOrKeep(FONT_SIZE)), 1);

          text.attr("font-size", (d) => font);
          text.attr("y", (d) => d.y - zoomOrKeep(FONT_BASELINE) + 8);
          link.attr("stroke-width", zoomOrKeep(STROKE));
          node.attr("r", (d) => {
            return zoomOrKeep(nodeSize[d.id]);
          });
          svg
            .selectAll("circle")
            .filter((_d, i, nodes) => d3.select(nodes[i]).attr("active"))
            .attr("r", (d) => zoomOrKeep(ACTIVE_RADIUS_FACTOR * nodeSize[d.id]));
        };

        const ticked = () => {
          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          text
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - (FONT_BASELINE - nodeSize[d.id]) / zoomLevel);
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        };

        const restart = () => {
          updateNodeSize();
          node = node.data(nodesData, (d) => d.id);
          node.exit().remove();
          node = node
            .enter()
            .append("circle")
            .attr("r", (d) => {
              return nodeSize[d.id];
            })
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(node);

          link = link.data(linksData, (d) => `${d.source.id}-${d.target.id}`);
          link.exit().remove();
          link = link.enter().append("line").attr("stroke-width", STROKE).merge(link);

          text = text.data(nodesData, (d) => d.label);
          text.exit().remove();
          text = text
            .enter()
            .append("text")
            .text((d) => shorten(d.label.replace(/_*/g, ""), MAX_LABEL_LENGTH))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

          node.attr("active", (d) => isCurrentPath(d.path) ? true : null);
          text.attr("active", (d) => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);
          simulation.alpha(1).restart();
          simulation.stop();

          for (let i = 0; i < TICKS; i++) {
            simulation.tick();
          }

          ticked();
        };

        const zoomHandler = d3.zoom().scaleExtent([0.2, 3]).on("zoom", resize);

        zoomHandler(svg);
        restart();

        function isCurrentPath(notePath) {
          return window.location.pathname.includes(notePath)
        }

        function shorten(str, maxLen, separator = ' ') {
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
      }
    }
  </script>
</div>

</main>
      <footer>


  <footer class="sticky-bottom mt-5" role="contentinfo">
    

    <div class="container">
      
  &copy; Copyright 2025
  Seoyeon
  
  Lee. 
  
  

    </div>
  </footer>

</footer>
    </div>

    <!-- That file is not particularly elegant. This will need a refactor at some point. -->
<style>
  content a.internal-link {
    border-color: #8b88e6;
    background-color: #efefff;
  }

  #tooltip-wrapper {
    background: white;
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 4px;
    overflow: hidden;
    position: absolute;
    width: 400px;
    height: 250px;
    font-size: 0.8em;
    box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity 100ms;
  }

  #tooltip-wrapper:after {
		content: "";
		position: absolute;
		z-index: 1;
		bottom: 0;
		left: 0;
		pointer-events: none;
		background-image: linear-gradient(to bottom, rgba(255,255,255, 0), rgba(255,255,255, 1) 90%);
		width: 100%;
		height: 75px;
  }
</style>

<div style="opacity: 0; display: none;" id='tooltip-wrapper'>
  <div id='tooltip-content'>
  </div>
</div>

<iframe style="display: none; height: 0; width: 0;" id='link-preview-iframe' src="">
</iframe>

<script>
  var opacityTimeout;
  var contentTimeout;
  var transitionDurationMs = 100;

  var iframe = document.getElementById('link-preview-iframe')
  var tooltipWrapper = document.getElementById('tooltip-wrapper')
  var tooltipContent = document.getElementById('tooltip-content')

  var linkHistories = {};

  function hideTooltip() {
    opacityTimeout = setTimeout(function() {
      tooltipWrapper.style.opacity = 0;
      contentTimeout = setTimeout(function() {
        tooltipContent.innerHTML = '';
        tooltipWrapper.style.display = 'none';
      }, transitionDurationMs + 1);
    }, transitionDurationMs)
  }

  function showTooltip(event) {
    var elem = event.target;
    var elem_props = elem.getClientRects()[elem.getClientRects().length - 1];
    var top = window.pageYOffset || document.documentElement.scrollTop

    if (event.target.host === window.location.host) {
      if (!linkHistories[event.target.href]) {
        iframe.src = event.target.href
        iframe.onload = function() {
          tooltipContentHtml = ''
          tooltipContentHtml += '<div style="font-weight: bold;">' + iframe.contentWindow.document.querySelector('h1').innerHTML + '</div>'
          tooltipContentHtml += iframe.contentWindow.document.querySelector('content').innerHTML

          tooltipContent.innerHTML = tooltipContentHtml
          linkHistories[event.target.href] = tooltipContentHtml

          tooltipWrapper.style.display = 'block';
          setTimeout(function() {
            tooltipWrapper.style.opacity = 1;
          }, 1)
        } 
      } else {
        tooltipContent.innerHTML = linkHistories[event.target.href]
        tooltipWrapper.style.display = 'block';
        setTimeout(function() {
          tooltipWrapper.style.opacity = 1;
        }, 1)
      }


      tooltipWrapper.style.left = elem_props.left - (tooltipWrapper.offsetWidth / 2) + (elem_props.width / 2) + "px";
      if ((window.innerHeight - elem_props.top) < (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top - tooltipWrapper.offsetHeight - 10 + "px";
      } else if ((window.innerHeight - elem_props.top) > (tooltipWrapper.offsetHeight)) {
          tooltipWrapper.style.top = elem_props.top + top + 35 + "px";
      }

      if ((elem_props.left + (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = "10px";
      } else if ((document.body.clientWidth - elem_props.left - (elem_props.width / 2)) < (tooltipWrapper.offsetWidth / 2)) {
          tooltipWrapper.style.left = document.body.clientWidth - tooltipWrapper.offsetWidth - 20 + "px";
      }
    }
  }

  function setupListeners(linkElement) {
    linkElement.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('mouseleave', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    tooltipWrapper.addEventListener('touchend', function(_event) {
      hideTooltip();
    });

    linkElement.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
      showTooltip(event);
    });

    tooltipWrapper.addEventListener('mouseenter', function(event) {
      clearTimeout(opacityTimeout);
      clearTimeout(contentTimeout);
    });
  }

  document.querySelectorAll('content a').forEach(setupListeners);
</script>

  </body>
</html>
